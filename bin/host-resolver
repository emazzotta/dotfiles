#!/usr/bin/env python3

import argparse
import platform
import queue
import socket
import subprocess
import sys
import threading
import time
from collections.abc import Iterator
from typing import Final


RESOLVE_TIMEOUT_MS: Final = 150
IS_DARWIN: Final = platform.system() == "Darwin"
HOSTS: Final[dict[str, tuple[str, ...]]] = {
    "ci-macmini": ("ci-macmini.machines.leonardo.local", "Mac-mini-von-Andreas.local"),
}

def try_host(hostname: str, timeout_ms: float) -> str | None:
    ping_flag = ["-W", str(int(timeout_ms) if IS_DARWIN else int(timeout_ms) // 1000)]
    try:
        ip = socket.gethostbyname(hostname)
        result = subprocess.run(["ping", "-c", "1"] + ping_flag + [ip], capture_output=True)
        if result.returncode == 0:
            print(f"Resolved {hostname} -> {ip}", file=sys.stderr)
            return ip
        return None
    except OSError:
        return None


def enforce_timeout(q: queue.Queue[str | None], count: int, timeout_ms: float) -> Iterator[str | None]:
    deadline = time.monotonic() + timeout_ms / 1000
    for _ in range(count):
        remaining = deadline - time.monotonic()
        if remaining <= 0:
            return
        try:
            yield q.get(timeout=remaining)
        except queue.Empty:
            return


def fetch_first_reachable(hostnames: tuple[str, ...], timeout_ms: float) -> str | None:
    results: queue.Queue[str | None] = queue.Queue()
    for hostname in hostnames:
        threading.Thread(target=lambda h=hostname: results.put(try_host(h, timeout_ms)), daemon=True).start()
    return next((ip for ip in enforce_timeout(results, len(hostnames), timeout_ms) if ip), None)


def resolve_hosts(short_name: str, timeout_ms: float) -> str:
    hostnames = HOSTS.get(short_name, (short_name,))
    if ip := fetch_first_reachable(hostnames, timeout_ms):
        return ip
    print(f"No reachable host found for {short_name}, falling back to 127.0.0.1", file=sys.stderr)
    return "127.0.0.1"


def main() -> None:
    parser = argparse.ArgumentParser(description="Resolve a host short name to an IP address")
    parser.add_argument("host", help="Short name (looked up in HOSTS) or a literal hostname/IP")
    parser.add_argument("-t", "--timeout", type=float, default=RESOLVE_TIMEOUT_MS, metavar="MS", help=f"Timeout in milliseconds (default: {RESOLVE_TIMEOUT_MS})")
    args = parser.parse_args()
    print(resolve_hosts(args.host, args.timeout))


if __name__ == "__main__":
    main()
